알고리즘	
	1. 1부터 주어진 수까지 진행하면서 나타나는 3, 6, 9를 모두 세는 것.
	2. 각 자리별로 숫자를 만들어 세되, 현재 수에서 이전에 계산된 값을 때서, 딱 떨어지도록 계산을 잘하자
		ex) int hund = (lastNum % 1000) - ten;
		    if(hund == 300 || hund == 600 || hund == 900)
			count++;


다른 알고리즘
	1. 나와 같이 반복문을 사용하여, 1씩 증가해가며 주어진 수에 도달할 때까지 나온 3 6 9 를 세는 것.
	2. 하지만 이 분은 나와는 달리, 특정한 temp에 10으로 나누었을때의 나머지가 3 6 9인지 확인하고, temp를 10으로 나눈다음 다시 확인하는 걸 temp가 0이 될때까지 반복함.
	3. 즉, 10으로 나누면서 각 자리에 3 6 9가 있는지 확인하는 것.
	4. 코드가 더 깔끔했다.

또 다른 알고리즘
	1. 내가 처음에 생각했던 알고리즘.
	2. 한 자리수가 3 6 9 일때는 - count += (lastNumber / (현재 자리수 + 1)*10) * 3 * (현재 자리수*10) + ((현재 자리수의 숫자 / 3) - 1) * (현재 자리수 * 10)
							 + lastNumber % (현재 자리수 * 10) + 1;
	   아닐 때는  count += (lastNumber / (현재 자리수 + 1)*10) * 3 * (현재 자리수*10) + (현재 자리수의 숫자 / 3) * (현재 자리수 * 10)
	3. 위와 같이 모든 자리수에 계산. 단, 일의 자리에서는 아래 식을 사용한다.
	*33일 때 박수는 두번친다. 따라서, 일의 자리가 3 6 9일때 박수를 친 횟수를 구하고, 십의 자리가 3 6 9일때 박수를 친 횟수를 구하는 건 독립적이다. 
	 예를 들어 구하는 수가 137일때, 일의 자리 수를 계산하면 - 13 * 3 + 2 = 41
					십의 자리 수를 계산하면 - (1 * 3 * 10) + 8 = 38	-> 두개를 그냥 더하면 된다.