알고리즘(백트래킹) : 내 방식
	1. 오른쪽 위에서 시작하여 왼쪽 아래로 내려오는 대각선을 기준으로 검사
	2. 하나의 대각선에서 내려오면서 놓을 수 있는 칸이고, 왼쪽 위를 검사했을때 이미 놓아진 비숍이 없으면 count 1증가하고 다음 대각선으로 이동
		-> 그 대각선에 놓을 수 있는 칸이 없을 경우 놓지않고 다음 대각선으로 이동
	3. 대각선이 끝까지 다오면 maxCount인지 검사하고, 종료 -> 재귀이기에 이전 상태로 돌아감 -> 이렇게 가능한 모든 경우의 수를 검사함.
	4. 그리고 한번 maxCount가 구해지면, 남은 대각선의 개수가 maxCount에 도달하기 위한 count의 개수보다 부족할경우 바로 거기서 return 가능.

	-> 체크 때문일까, 시간이 392 이하로 줄일 수 없음. 
	-> 더 빠른 코드를 참고해보자.

알고리즘(백트래킹) : 다른 분 방식
	1. 대각선에 번호를 매김.  / 대각선 0~2*(width-1)번까지 나오고, \ 대각선 0~2*(width-1)번까지 나옴
	2. 한 대각선을 넣으면, 해당하는 칸의 / 대각선, \ 대각선에 true를 표시함.
	3. 그러면 이후 check할때 check를 하는 칸의 / 대각선 \ 대각선이 true인지 확인하면 됨.
		

	-> 192ms 로 줄임
	-> 더 줄이는건 포기. 어케해ㅅㅂ