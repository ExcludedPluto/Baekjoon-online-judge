문법
	전역변수는 0으로 초기화됨.

정렬
	algorithm
	sort(시작 위치, 끝 위치); 	// 끝위치는 sizeof 안써도 된다. 그냥 배열 크기만큼 시작위치에서 더해주자.
	sort(시작위치, 끝 위치, 정렬 함수명)
	sort(vector.begin(), vector.end())
	
	정렬함수는 true일 경우 앞에있는 것이 앞에오도록 한다.

	list의 경우 정렬시 list.sort() 로 사용한다

초기화
	cstring
	memset(arr, 0 || -1, sizeof(arr));
	memcpy(des, source, sizeof(int)*20);

이차원 배열 리턴
	int (*getMap(void)[MAX_WIDTH];	//함수 선언부를 이렇게 한다.
	int (*map)[MAX_WIDTH] = (int(*)[MAX_WIDTH])getmap();		//받을땐 이렇게

algorithm
	순열
		bool next_permutation (BidirectionalIterator first, BidirectionalIterator last);		// 1-2-3-4를 넣으면 1-2-4-3 으로 바뀌고, true반환
			//next_permutation(vector.begin(), vector.end());
		bool next_permutation (BidirectionalIterator first, BidirectionalIterator last, Compare comp);
	
	이진탐색
		binary_search( .begin(), .end(), v)
			첫번째에 시작주소, 두번째에 끝주소 + 1, 세번째에 찾는 값
			찾으면 true, 못찾으면 false 반환
		lower_bound( .begin(), .end(), v)
			v 이상이 처음 나타나는 곳의 포인터 반환
			못찾으면 end() 반환
		upper_bound( .begin(), .end(), v)
			v 초과가 처음 나타나는 곳의 포인터 반환
			못찾으면 end() 반환



set과 multiset
	-set : 중복이 없는 집합. 넣을 때마다 이진트리 형태로 값이 정렬되어 저장된다.
	-multiset : 중복이 있는 집합. 넣을 때마다 이진트리 형태로 값이 정렬되어 저장됨
	
	연산자
		end() : 집합의 끝에서 한번 더 간 곳에 해당하는 반복자를 반환함
		find()	: 찾으면 그 위치의 반복자를 반환. 없으면 end()에 해당하는 값을 반환함.
		insert() : 값을 넣고, 넣은 자리의 반복자를 반환함
		erase()	: 반복자를 넣고, 그 자리에 해당하는 원소를 삭제함. 그리고 그 삭제한 원소 + 1에 해당하는 반복자를 반환한다.
		count(k) : 원소 k의 개수를 반환. set이면 0또는 1, multiset이면 있는만큼
		clear() : 비우기
		
	
	반복자
		set<int>::iterator temp; 	식으로 선언해야함
		temp++ 또는 temp-- 식으로 다음, 이전 반복자로 접근 가능.(temp + 1)은 안통한다
		*temp	로 이 반복자가 가리키는 원소의 값을 참조할 수 있음.


입력
	cin.getline(char *str, size)	최대 size인 문자열을 받음
					끝에는 \0이 저장됨