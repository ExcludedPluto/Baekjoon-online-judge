알고리즘(BFS, 구현)
	1. 방문한 곳을 체크하는 check 이차원 배열, 키를 저장하는 key 배열, 닫힌문을 저장하는 closedDoor 벡터가 필요
	2. 먼저 키 배열은 26개의 원소로 이루어진 bool 자료형 배열로 선언. 각 알파벳에 해당하는 키가 들어오면 1을 저장한다.
	3. 방문가능한지 체크하는 checkCell 함수 선언
		-> 빈공간이면 true반환, 문서면 빈공간으로 전환 후 document 1증가하고 true반환
		   소문자면 열쇠 추가하고, 빈공간으로 전환 후 truw반환
		   대문자고, 열쇠가 있으면 빈공간으로 전환 후 true 반환
		   대문자고 열쇠가 없으면 closedDoor 벡터에 해당위치 추가하고 false 반환
	4. 처음에 테두리 먼저 검사
		-> 체크 안됐고, 벽이 아니고, checkCell 통과하면 해당 위치에서 BFS 시행
		-> 모든 테두리 검사
	5. 테두리 검사 후. cloesedDoor 검사
		-> 체크 안됐고, 빈공간 전환 안됐고, 열쇠있으면 빈공간으로 전환 후 BFS 시행
		-> 한번이라도 BFS가 시행되면 다시 처음부터 closedDoor검사를 함.
		-> BFS가 시행안되면 루프 중단 후 document 수 출력

키 포인트
	1. 한번 검사한 cell은 다시 검사하지 않는다. -> 검사안된 곳은 열쇠가 없어서 못들어간 곳이므로, closedDoor만 검사하면 된다.
	2. 입력잘받자 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		
	문자열 입력
		1. 길이를 정해줬을 때
			: 띄어쓰기를 안했다해도, 그냥 map[i][j] 로 받으면 된다.
		2. 길이를 안정해줬을 떄
			: 	string temp;
				cin >> tmep;
				for(int i = 0; i<temp.length(); i++)
					key[i] = temp[i];
				로 받자