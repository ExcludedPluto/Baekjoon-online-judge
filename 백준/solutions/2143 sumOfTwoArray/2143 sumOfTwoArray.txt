알고리즘(이분탐색, 누적합)
	1. A배열은 그대로 두고, B 배열은 가능한 모든 누적합의 집합을 만들고, 그것을 정렬함
			-> 이때 그냥 배열에 집어넣으면 최대 500500개의 원소가 있어서 메모리에서 박살나고, 찾는데 시간도 박살남
			-> 난 set을 택했음
			-> Pair 구조체를 선언해서, 누적합과 그 누적합이 나온 횟수를 저장함. 그리고 정렬과 비교연산자를 오버로딩하여 set에서 활용할 수 있게함
			-> B의 누적합을 하나씩 만들어가며, set에 있는지 확인 -> 있으면 set에 이미 있는 Pair 객체의 count에 1을 더하고, 새로운 pair 객체에 넣음.
										그 다음, 원래 있던 Pair 객체를 지우고, 새로만든 Pair 객체를 집어넣음
									     -> 없으면 set에 구한 누적합과 count에 1을 넣어 만든 Pair 객체를 set에 삽입
	2. A배열의 누적합을 하나씩 만들어가며 B에 (T-누적합)을 가지는 Pair객체가 있는 지 확인
		-> 있으면, 그 객체의 count를 전체 count에 더함
		-> 없으면, 그냥 패스

	3. 전체 count는 int 범위를 넘을 수 있음


주의점 
	1. set에 구조체를 넣을때, 구조체 안에 오버로딩을 선언하는 경우 다음처럼 해야한다.
		bool operator < (const Pair& p) const{
			return value < p.value;
		}
		안그럼 오류남
	